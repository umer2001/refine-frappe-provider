{"version":3,"sources":["../../src/client/client.ts","../../src/accessControl/accessControlType.ts","../../src/accessControl/accessControlTypeHelper.ts","../../src/accessControl/accessControlTransformer.ts","../../src/accessControl/accessControlClient.ts","../../src/accessControl/accessControlProvider.ts","../../src/utils/handleUnknownError.ts","../../src/utils/httpStatusCode.ts","../../src/utils/isHttpError.ts","../../src/auth/authClient.ts","../../src/auth/authProvider.ts","../../src/data/utils/generateFilter.ts","../../src/data/utils/generatePagination.ts","../../src/data/utils/generateSort.ts","../../src/data/dataClient.ts","../../src/data/dataProvider.ts"],"sourcesContent":["import {\n  type HttpError,\n} from \"@refinedev/core\";\nimport axios, {\n  type AxiosInstance,\n  type CreateAxiosDefaults,\n} from \"axios\";\n\nexport interface ClientParams {\n  url: string;\n  axiosConfig?: Partial<CreateAxiosDefaults>;\n}\n\nexport class Client {\n  url: string;\n  instance: AxiosInstance;\n\n  constructor(params: ClientParams) {\n    const {\n      axiosConfig = {},\n      url,\n    } = params;\n    const {\n      headers,\n      ...restAxiosConfig\n    } = axiosConfig;\n\n    this.url = url;\n    this.instance = axios.create({\n      baseURL: url,\n      headers: {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n        ...headers,\n      },\n      withCredentials: true,\n      ...restAxiosConfig,\n    });\n\n    this.instance.interceptors.response.use(\n      (response) => {\n        if (\"message\" in response.data) {\n          response.data = response.data.message;\n        }\n        else if (Object.keys(response.data).length === 1 && \"data\" in response.data) {\n          response.data = response.data.data;\n        }\n\n        return response;\n      },\n      (error) => {\n        const errorMsg = error.response?.data?.message\n          || error.response?.statusText\n          || error.response?.data?.exc_type;\n\n        const customError: HttpError = {\n          message: errorMsg,\n          statusCode: error.response?.status,\n        };\n\n        return Promise.reject(customError);\n      },\n    );\n  }\n}\n","import {\n  type BaseKey,\n} from \"@refinedev/core\";\n\n/**\n * Frappe has_permission api required docname params\n * but it's actuall optional params.\n *\n * For example, user can has read permission\n * only if user is owner.\n */\nexport enum PermissionType {\n  read = \"read\",\n  write = \"write\",\n  submit = \"submit\",\n  cancel = \"cancel\",\n  report = \"report\",\n  create = \"create\",\n  delete = \"delete\",\n}\n\nexport interface FpCanParams {\n  docname: BaseKey | \"\";\n  doctype: string;\n  perm_type: PermissionType;\n}\n","import {\n  PermissionType,\n} from \"./accessControlType\";\n\nexport const isPermissionType = (value: string): value is PermissionType => value in PermissionType;\n","import { type CanParams } from \"@refinedev/core\";\n\nimport { type FpCanParams } from \"./accessControlType\";\nimport { isPermissionType } from \"./accessControlTypeHelper\";\n\nexport const tCanParams = (params: CanParams): FpCanParams => {\n  const {\n    action,\n    params: canParams = {},\n    resource,\n  } = params;\n\n  const { id = \"\" } = canParams;\n\n  if (!resource) {\n    throw new TypeError(\"Resource is required\");\n  }\n\n  if (!isPermissionType(action)) {\n    throw new TypeError(\"Invalid action\");\n  }\n\n  return {\n    docname: id,\n    doctype: resource,\n    perm_type: action,\n  };\n};\n","import {\n  type CanParams,\n  type CanReturnType,\n  type AccessControlProvider,\n  type IAccessControlContext,\n} from \"@refinedev/core\";\n\nimport { Client, ClientParams } from \"@/client\";\n\nimport { tCanParams } from \"./accessControlTransformer\";\n\nexport type AccessControlParams = ClientParams;\nexport type AccessControlProviderParams = Pick<IAccessControlContext, \"options\">;\n\nclass AccessControlClient extends Client {\n  provider(\n    props: AccessControlProviderParams = {},\n  ): AccessControlProvider {\n    const { options } = props;\n\n    return {\n      can: this.can,\n      options,\n    };\n  }\n\n  can = async (params: CanParams): Promise<CanReturnType> => {\n    try {\n      const fpParams = tCanParams(params);\n\n      const {\n        data: { has_permission },\n      } = await this.instance.request<{\n        has_permission: boolean;\n      }>({\n        method: \"GET\",\n        params: fpParams,\n        url: \"/api/method/frappe.client.has_permission\",\n      });\n\n      return {\n        can: Boolean(has_permission),\n      };\n    }\n    catch (error: unknown) {\n      return {\n        can: false,\n      };\n    }\n  };\n}\n\nexport default AccessControlClient;\n","import {\n  type AccessControlProvider,\n} from \"@refinedev/core\";\n\nimport AccessControlClient, {\n  type AccessControlParams,\n  type AccessControlProviderParams,\n} from \"./accessControlClient\";\n\nconst accessControlProvider = (\n  params: AccessControlParams & AccessControlProviderParams,\n): AccessControlProvider => {\n  const {\n    options = {},\n    ...clientParams\n  } = params;\n\n  const client = new AccessControlClient(clientParams);\n\n  return client.provider({ options });\n};\n\nexport default accessControlProvider;\n","import {\n  type HttpError,\n} from \"@refinedev/core\";\n\nimport { isHttpError } from \"@/utils\";\n\ntype handleUnkownErrorParams = {\n  error: unknown;\n  errorWhile?: string;\n};\n\nexport const handleUnkownError = (\n  params: handleUnkownErrorParams,\n): Error | HttpError => {\n  const { error, errorWhile } = params;\n\n  if (isHttpError(error)) {\n    return error;\n  }\n\n  if (errorWhile) {\n    return new Error(\n      `An unknown error occurred while ${errorWhile}.`,\n    );\n  }\n\n  return new Error(\"An unknown error occurred.\");\n};\n","export { HttpStatusCode } from \"axios\";\n","import { type HttpError } from \"@refinedev/core\";\n\nexport const isHttpError = (error: unknown): error is HttpError => (\n  typeof error === \"object\"\n  && error !== null\n  && \"message\" in error\n  && \"statusCode\" in error\n);\n","/* global document */\n\nimport { type AuthProvider } from \"@refinedev/core\";\n\nimport { Client, ClientParams } from \"@/client\";\nimport { handleUnkownError } from \"@/utils\";\n\nimport {\n  AuthActionResponse,\n  LoginParams,\n  LogoutParams,\n  CheckParams,\n  CheckResponse,\n  OnErrorResponse,\n} from \"./authType\";\n\nexport type AuthParams = ClientParams;\n\nclass AuthClient extends Client {\n  provider(): AuthProvider {\n    return {\n      check: this.check,\n      login: this.login,\n      logout: this.logout,\n      onError: this.onError,\n    };\n  }\n\n  login = async (params: LoginParams): Promise<AuthActionResponse> => {\n    const { pwd, redirectTo = \"/\", usr } = params;\n\n    try {\n      await this.instance.request({\n        data: {\n          pwd,\n          usr,\n        },\n        method: \"POST\",\n        url: \"/api/method/login\",\n      });\n\n      return {\n        redirectTo,\n        success: true,\n      };\n    }\n    catch (error: unknown) {\n      return {\n        error: handleUnkownError({\n          error,\n          errorWhile: \"logging in\",\n        }),\n        redirectTo,\n        success: false,\n      };\n    }\n  };\n\n  logout = async (params: LogoutParams): Promise<AuthActionResponse> => {\n    const { redirectTo = \"/\" } = params || {};\n\n    try {\n      await this.instance.request({\n        method: \"POST\",\n        url: \"/api/method/logout\",\n      });\n\n      return {\n        redirectTo,\n        success: true,\n      };\n    }\n    catch (error: unknown) {\n      return {\n        error: handleUnkownError({\n          error,\n          errorWhile: \"logging out\",\n        }),\n        redirectTo,\n        success: false,\n      };\n    }\n  };\n\n  check = async (params?: CheckParams): Promise<CheckResponse> => {\n    const { redirectTo = \"/\" } = params || {};\n\n    try {\n      /**\n       * `get_logged_user` method doesn't allow Guest\n       * if it's calling by Guest it will response with 403\n       * so we skip it and just return false\n       */\n      if (\n        typeof document !== \"undefined\"\n        && typeof document.cookie === \"string\"\n        && (\n          document.cookie === \"\"\n          || document.cookie.includes(\"user_id=Guest\")\n        )\n      ) {\n        return {\n          authenticated: false,\n          redirectTo,\n        };\n      }\n\n      await this.instance.request({\n        method: \"GET\",\n        url: \"/api/method/frappe.auth.get_logged_user\",\n      });\n\n      return {\n        authenticated: true,\n        redirectTo,\n      };\n    }\n    catch (error: unknown) {\n      return {\n        authenticated: false,\n        redirectTo,\n      };\n    }\n  };\n\n  // eslint-disable-next-line class-methods-use-this\n  onError = (error: unknown): Promise<OnErrorResponse> => {\n    const response: OnErrorResponse = {\n      error: handleUnkownError({\n        error,\n      }),\n    };\n\n    return Promise.resolve(response);\n  };\n}\n\nexport default AuthClient;\n","import {\n  type AuthProvider,\n} from \"@refinedev/core\";\n\nimport AuthClient, { AuthParams } from \"./authClient\";\n\nconst authProvider = (\n  params: AuthParams,\n): AuthProvider => {\n  const client = new AuthClient(params);\n\n  return client.provider();\n};\n\nexport default authProvider;\n","import {\n  type CrudFilter,\n  type CrudFilters,\n  type CrudOperators,\n} from \"@refinedev/core\";\n\ntype FrappeFilter = [string, string, string];\ntype FilterResponse = FrappeFilter[];\n\nconst OPERATOR_MAP = {\n  between: \"between\",\n  contains: \"like\",\n  eq: \"=\",\n  gt: \">\",\n  gte: \">=\",\n  in: \"in\",\n  lt: \"<\",\n  lte: \"<=\",\n  ncontains: \"not like\",\n  ne: \"!=\",\n  nin: \"not in\",\n};\nconst UNSUPPORTED_OPERATORS_MAP = {\n  and: null,\n  containss: null,\n  endswith: null,\n  endswiths: null,\n  nbetween: null,\n  ncontainss: null,\n  nendswith: null,\n  nendswiths: null,\n  nnull: null,\n  nstartswith: null,\n  nstartswiths: null,\n  null: null,\n  or: null,\n  startswith: null,\n  startswiths: null,\n};\nconst CRUD_OPERATORS: Record<CrudOperators, string | null> = {\n  ...OPERATOR_MAP,\n  ...UNSUPPORTED_OPERATORS_MAP,\n};\n\n/**\n * Maps a CRUD operator to its corresponding string representation.\n * @param operator - The CRUD operator to map.\n * @returns The string representation of the mapped operator.\n * @throws Error if the provided operator is not supported.\n * @example\n * mapOperator(\"eq\");\n * return: \"=\"\n */\nexport const mapOperator = (operator: CrudOperators): string => {\n  const mappedOperator = CRUD_OPERATORS[operator];\n  if (mappedOperator) {\n    return mappedOperator;\n  }\n  throw new Error(\n    `[refine-frappe]: \\`operator: ${operator}\\` is not supported.`,\n  );\n};\n\n/**\n * Transforms a logical filter into a Frappe filter.\n * @param filter - The logical filter to transform.\n * @returns The transformed Frappe filter.\n * @example\n * transformFilter({\n *   field: 'name',\n *   operator: 'equals',\n *   value: 'John Doe'\n * });\n * return: ['name', '=', 'John Doe']\n */\nconst transformFilter = (filter: CrudFilter): FrappeFilter => {\n  if (!(\"field\" in filter)) {\n    throw new Error(\n      `[refine-frappe]: \\`filter\\` must be a logical filter.`,\n    );\n  }\n  const { field, operator, value } = filter;\n  const mappedOperator = mapOperator(operator);\n  return [field, mappedOperator, value];\n};\n\n/**\n * Generates a filter response based on the provided filters.\n * @param filters - The filters to generate the response from only supports andFilter for now\n * @returns The generated filter response.\n * @example\n * generateFilter([\n *   { field: 'name', operator: 'eq', value: 'John' },\n *   { field: 'age', operator: 'gt', value: 18 },\n * ]);\n * return: [\n *   ['name', '=', 'John'],\n *   ['age', '>', 18],\n * ]\n */\nexport const generateFilter = (filters?: CrudFilters): FilterResponse => {\n  // If no filters are provided, return an empty array.\n  if (!filters) {\n    return [];\n  }\n\n  const queryFilters: FilterResponse = [];\n  filters.forEach((filter) => {\n    queryFilters.push(transformFilter(filter));\n  });\n  return queryFilters;\n};\n","import {\n  type Pagination,\n} from \"@refinedev/core\";\n\ntype FrappePagination = {\n  limit_page_start: number;\n  limit_page_length: number;\n};\n\nexport const generatePagination = (props: Pagination | undefined = {}): FrappePagination => {\n  const DEFAULT_PAGE_SIZE = 10;\n  const DEFAULT_PAGE = 1;\n\n  const {\n    current = DEFAULT_PAGE,\n    pageSize = DEFAULT_PAGE_SIZE,\n  } = props;\n\n  return {\n    limit_page_length: pageSize,\n    limit_page_start: (current - 1) * pageSize,\n  };\n};\n","import {\n  CrudSorting,\n} from \"@refinedev/core\";\n\nexport const generateSort = (sorters?: CrudSorting): string | undefined => {\n  if (!(sorters && sorters.length > 0)) {\n    // eslint-disable-next-line no-undefined\n    return undefined;\n  }\n\n  const sorterList = sorters.map((item) => `${item.field} ${item.order}`);\n\n  return sorterList.join(\",\");\n};\n","import {\n  type DataProvider,\n  type BaseRecord,\n  type GetListParams,\n  type GetListResponse,\n  type GetManyParams,\n  type GetManyResponse,\n  type CreateParams,\n  type CreateResponse,\n  type UpdateParams,\n  type UpdateResponse,\n  type GetOneParams,\n  type GetOneResponse,\n  type DeleteOneParams,\n  type DeleteOneResponse,\n  type CustomParams,\n  type CustomResponse,\n} from \"@refinedev/core\";\n\nimport { Client, ClientParams } from \"@/client\";\n\nimport { Doc } from \"./dataTypes\";\nimport { generateFilter, generatePagination, generateSort } from \"./utils\";\n\nexport type DataParams = ClientParams;\n\nclass DataClient extends Client {\n  provider(): DataProvider {\n    return {\n      create: this.create,\n      custom: this.custom,\n      deleteOne: this.deleteOne,\n      getApiUrl: this.getApiUrl,\n      getList: this.getList,\n      getMany: this.getMany,\n      getOne: this.getOne,\n      update: this.update,\n    };\n  }\n\n  getList = async <TData extends BaseRecord = BaseRecord>(\n    params: GetListParams\n  ): Promise<GetListResponse<TData>> => {\n    const { filters, meta, pagination, resource, sorters } = params;\n\n    const fpFilters = generateFilter(filters);\n    const fpPagination = generatePagination(pagination);\n    const fpSorter = generateSort(sorters);\n\n    const { data } = await this.instance.request<TData[]>({\n      method: \"GET\",\n      params: {\n        doctype: resource,\n        fields: JSON.stringify(meta?.fields || [\"name\"]),\n        filters: JSON.stringify(fpFilters),\n        limit: fpPagination.limit_page_length,\n        limit_start: fpPagination.limit_page_start,\n        order_by: fpSorter,\n      },\n      url: `/api/resource/${resource}`,\n    });\n    const { data: total } = await this.instance.request<number>({\n      method: \"GET\",\n      params: {\n        doctype: resource,\n        filters: JSON.stringify(fpFilters),\n      },\n      url: `/api/v2/doctype/${resource}/count`,\n    });\n\n    return {\n      data,\n      total,\n    };\n  };\n\n  getMany = async <TData extends BaseRecord = BaseRecord>(\n    params: GetManyParams\n  ): Promise<GetManyResponse<TData>> => {\n    const { ids, meta, resource } = params;\n\n    const { data } = await this.instance.request<TData[]>({\n      method: \"GET\",\n      params: {\n        doctype: resource,\n        fields: JSON.stringify(meta?.fields || [\"name\"]),\n        filters: JSON.stringify([[\"name\", \"in\", ids]]),\n      },\n      url: `/api/resource/${resource}`,\n    });\n\n    return { data };\n  };\n\n  create = async <\n    TData extends BaseRecord = BaseRecord,\n    TVariables = Partial<TData>\n  >(\n    params: CreateParams<TVariables>\n  ): Promise<CreateResponse<Doc<TData>>> => {\n    const { resource, variables } = params;\n\n    const { data } = await this.instance.request<Doc<TData>>({\n      data: variables,\n      method: \"POST\",\n      url: `/api/resource/${resource}`,\n    });\n\n    return { data };\n  };\n\n  update = async <\n    TData extends BaseRecord = BaseRecord,\n    TVariables = Partial<TData>\n  >(\n    params: UpdateParams<TVariables>\n  ): Promise<UpdateResponse<Doc<TData>>> => {\n    const { id, resource, variables } = params;\n\n    const { data } = await this.instance.request<Doc<TData>>({\n      data: variables,\n      method: \"PUT\",\n      url: `/api/resource/${resource}/${id}`,\n    });\n\n    return { data };\n  };\n\n  getOne = async <TData extends BaseRecord = BaseRecord>(\n    params: GetOneParams\n  ): Promise<GetOneResponse<Doc<TData>>> => {\n    const { id, resource } = params;\n\n    const { data } = await this.instance.request<Doc<TData>>({\n      method: \"GET\",\n      url: `/api/resource/${resource}/${id}`,\n    });\n\n    return { data };\n  };\n\n  deleteOne = async <\n    TData extends BaseRecord = BaseRecord,\n    TVariables = object\n  >(\n    params: DeleteOneParams<TVariables>\n  ): Promise<DeleteOneResponse<TData>> => {\n    const { id, resource } = params;\n\n    await this.instance.request<\"ok\">({\n      method: \"DELETE\",\n      url: `/api/resource/${resource}/${id}`,\n    });\n\n    /**\n     * Since Frappe only response with \"ok\" string,\n     * we won't have full data of the deleted record.\n     *\n     * We will return the id of the deleted record instead.\n     */\n\n    return {\n      data: {\n        id,\n      },\n    } as DeleteOneResponse<TData>;\n  };\n\n  custom = async <\n    TData extends BaseRecord = BaseRecord,\n    TQuery = unknown,\n    TPayload = unknown\n  >(\n    params: CustomParams<TQuery, TPayload>\n  ): Promise<CustomResponse<TData>> => {\n    const { method, payload, url } = params;\n\n    const { data } = await this.instance.request({\n      data: payload,\n      method,\n      url,\n    });\n\n    return { data };\n  };\n\n  getApiUrl = (): string => this.url;\n}\n\nexport default DataClient;\n","import {\n  type DataProvider,\n} from \"@refinedev/core\";\n\nimport DataClient, { DataParams } from \"./dataClient\";\n\nconst dataProvider = (\n  params: DataParams,\n): DataProvider => {\n  const client = new DataClient(params);\n\n  return client.provider();\n};\n\nexport default dataProvider;\n"],"mappings":"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","names":["axios","Client","params","axiosConfig","url","headers","restAxiosConfig","response","error","customError","PermissionType","isPermissionType","value","PermissionType","tCanParams","params","action","canParams","resource","id","isPermissionType","AccessControlClient","Client","props","options","params","fpParams","tCanParams","has_permission","accessControlClient_default","accessControlProvider","params","options","clientParams","accessControlClient_default","accessControlProvider_default","handleUnkownError","params","error","errorWhile","isHttpError","HttpStatusCode","isHttpError","error","AuthClient","Client","params","pwd","redirectTo","usr","error","handleUnkownError","response","authClient_default","authProvider","params","authClient_default","authProvider_default","OPERATOR_MAP","UNSUPPORTED_OPERATORS_MAP","CRUD_OPERATORS","mapOperator","operator","mappedOperator","transformFilter","filter","field","value","generateFilter","filters","queryFilters","generatePagination","props","current","pageSize","generateSort","sorters","item","DataClient","Client","params","filters","meta","pagination","resource","sorters","fpFilters","generateFilter","fpPagination","generatePagination","fpSorter","generateSort","data","total","ids","variables","id","method","payload","url","dataClient_default","dataProvider","params","dataClient_default","dataProvider_default"]}